__author__ = "Tony Yamin"
__email__ = "ty2492"

#======================================================================#
#*#*#*# Optional: Import any allowed libraries you may need here #*#*#*#
#======================================================================#
import queue
import resource
import time
#=================================#
#*#*#*# Your code ends here #*#*#*#
#=================================#

import argparse

if __name__ == "__main__":
	parser = argparse.ArgumentParser(description='Robot Path Planning | HW 1 | COMS 4701')
	parser.add_argument('-bfs', action="store_true", default=False , help="Run BFS on the map")
	parser.add_argument('-dfs', action="store_true", default=False, help= "Run DFS on the map")
	parser.add_argument('-astar', action="store_true", default=False, help="Run A* on the map")
	parser.add_argument('-ida', action="store_true", default=False, help="Run Iterative Deepening A* on the map")
	parser.add_argument('-all', action="store_true", default=False, help="Run all the 4 algorithms")
	parser.add_argument('-m', action="store", help="Map filename")

	results = parser.parse_args()

	if results.m=="" or not(results.all or results.astar or results.bfs or results.dfs or results.ida):
		print("Check the parameters : >> python hw1_UNI.py -h")
		exit()

	if results.all:
		results.bfs = results.dfs = results.astar = results.ida = True

	# Reading of map given and all other initializations
	try:
		with open(results.m) as f:
			arena = f.read()
			arena = arena.split("\n")
	except:
		print("Error in reading the arena file.")
		exit()

	# Internal representation
	print(arena)

	print("The arena of size "+ str(len(arena)) + "x" + str(len(arena[0])))
	print("\n".join(arena))

class MazeState:
    """
    This class is an abstraction to store a maze state, which contains the following:
    - Maze configuration (arena)
    - Current Position (position in the the maze that the current state represents)
    - Parent (the state from which the current state came from)
    - Action (the action taken in the parent state, direction moved, which lead to the creation of the current state)
    - Cost (Cost  of the path taken from the start to the current state)
    - Children (a child of the current state is generated by moving in a direction)
    """

    def get_start_index(self):
        """
        Returns the start index of the maze based on the given arena
        returns (-1, -1) if no start index found
        """
        # =======================================================================#
        # *#*#*# TODO: Write your code to find the start index of the maze #*#*#*#
        # =======================================================================#
        for row_index, row in enumerate(self.arena):
            for col_index, char in enumerate(row):
                if char == "s":
                    return (row_index, col_index)

        return (-1, -1)
        # =================================#
        # *#*#*# Your code ends here #*#*#*#
        # =================================#

    def get_goal_index(self):
        """
        Returns the goal index of the maze based on the given arena
        returns (-1, -1) if no goal index found
        """
        # ======================================================================#
        # *#*#*# TODO: Write your code to find the goal index of the maze #*#*#*#
        # ======================================================================#
        for row_index, row in enumerate(self.arena):
            for col_index, char in enumerate(row):
                if char == "g":
                    return (row_index, col_index)

        return (-1, -1)
        # =================================#
        # *#*#*# Your code ends here #*#*#*#
        # =================================#

    def __init__(
        self, arena, parent=None, action="Start", cost=0, current_position=(-1, -1)
    ):
        self.arena = arena
        self.parent = parent
        self.action = action
        self.cost = cost
        self.children = []

        self.start = self.get_start_index()
        self.goal = self.get_goal_index()

        if current_position[0] == -1:
            self.current_position = self.start
        else:
            self.current_position = current_position

    def display(self):
        print("\n".join(self.arena))

    def move_up(self):
        """
        This function checks if up is a valid move from the given state.
        If up is a valid move, returns a child in which the player has moved up
        Else returns None.
        """

        # =================================================================#
        # *#*#*# TODO: Write your code to move up in the puzzle here #*#*#*#
        # =================================================================#
        next_position = (self.current_position[0] - 1, self.current_position[1])
        if self.is_Valid(next_position):
            return MazeState(self.arena, parent=self, action="Up", cost=self.cost + 1, current_position=next_position)

        return None
        # =================================#
        # *#*#*# Your code ends here #*#*#*#
        # =================================#

    def move_down(self):
        """
        This function checks if down is a valid move from the given state.
        If down is a valid move, returns a child in which the player has moved down.
        Else returns None.
        """

        # ===================================================================#
        # *#*#*# TODO: Write your code to move down in the puzzle here #*#*#*#
        # ===================================================================#
        next_position = (self.current_position[0] + 1, self.current_position[1])
        if self.is_Valid(next_position):
            return MazeState(self.arena, parent=self, action="Down", cost=self.cost + 1, current_position=next_position)

        return None
        # =================================#
        # *#*#*# Your code ends here #*#*#*#
        # =================================#

    def move_left(self):
        """
        This function checks if left is a valid move from the given state.
        If left is a valid move, returns a child in which the player has moved left.
        Else returns None.
        """

        # ===================================================================#
        # *#*#*# TODO: Write your code to move left in the puzzle here #*#*#*#
        # ===================================================================#
        next_position = (self.current_position[0], self.current_position[1] - 1)
        if self.is_Valid(next_position):
            return MazeState(self.arena, parent=self, action="Left", cost=self.cost + 1, current_position=next_position)

        return None
        # =================================#
        # *#*#*# Your code ends here #*#*#*#
        # =================================#

    def move_right(self):
        """
        This function checks if left is a valid move from the given state.
        If left is a valid move, returns a child in which the player has moved left.
        Else returns None.
        """

        # ====================================================================#
        # *#*#*# TODO: Write your code to move right in the puzzle here #*#*#*#
        # ====================================================================#
        next_position = (self.current_position[0], self.current_position[1] + 1)
        if self.is_Valid(next_position):
            return MazeState(self.arena, parent=self, action="Right", cost=self.cost + 1, current_position=next_position)

        return None
        # =================================#
        # *#*#*# Your code ends here #*#*#*#
        # =================================#

    def expand(self):
        """
        Generate the child nodes of this node
        """

        if len(self.children) != 0:
            return self.children

        # Do not change the order in this function, since the grading script assumes this order of expansion when checking
        children = [
            self.move_up(),
            self.move_right(),
            self.move_down(),
            self.move_left(),
        ]

        self.children = [state for state in children if state is not None]
        return self.children

    def __hash__(self):
        """
        Maze states hashed based on cost.
        This function may be modified if required.
        """
        # ============================================================================================#
        # *#*#*# Optional: May be modified if your algorithm requires a different hash function #*#*#*#
        # ============================================================================================#

        return self.cost

        # =================================#
        # *#*#*# Your code ends here #*#*#*#
        # =================================#

    def __eq__(self, other):
        """
        Maze states are defined as equal if they have the same dimensions and the same current position.
        This function may be modified if required.
        """

        # =============================================================================================#
        # *#*#*# Optional: May be modified if your algorithm requires a different equality check #*#*#*#
        # =============================================================================================#

        m1 = self.arena
        m2 = other.arena

        if len(m1) != len(m2):
            return False

        for i in range(0, len(m1)):
            if not (m1[i] == m2[i]):
                return False

        return self.current_position == other.current_position

        # =================================#
        # *#*#*# Your code ends here #*#*#*#
        # =================================#

    # =====================================================================================#
    # *#*#*# Optional: Write any other functions you may need in the MazeState Class #*#*#*#
    # =====================================================================================#
    def __lt__(self, other):
        return self.total_state_cost() < other.total_state_cost()

    def total_state_cost(self):
        return total_cost(self)

    def is_Valid(self, position):
        row, col = position
        return 0 <= row < len(self.arena) and 0 <= col < len(self.arena[0]) and self.arena[row][col] != "o"
    # =================================#
    # *#*#*# Your code ends here #*#*#*#
    # =================================#


# ================================================================================#
# *#*#*# Optional: You may write helper functions in this space if required #*#*#*#
# ================================================================================#
def find_path(current_state):
    path = []

    while current_state.parent is not None:
        path.append(current_state.current_position)
        current_state = current_state.parent

    path.append(current_state.current_position)
    return path

def final_arena(arena, path):
    arena_list = []
    for row in arena:
        arena_list.append(list(row))
    
    for x,y in path:
        if arena_list[x][y] not in ("s", "g"):
            arena_list[x][y] = "*"
    
    result_arena = []
    for row in arena_list:
        result_arena.append(''.join(row))
    
    return result_arena

def total_cost(state):
    return state.cost + abs(state.current_position[0] - state.goal[0]) + abs(state.current_position[1] - state.goal[1])

# =================================#
# *#*#*# Your code ends here #*#*#*#
# =================================#


"""
This function runs Breadth First Search on the input arena (which is a list of str)
Returns a ([], int) tuple where the [] represents the solved arena as a list of str and the int represents the cost of the solution
"""


def bfs(arena):
    # =================================================#
    # *#*#*# TODO: Write your BFS algorithm here #*#*#*#
    # =================================================#
    start_time = time.time()
    start_ram = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss

    initial_state = MazeState(arena)
    goal_position = initial_state.goal

    frontier = queue.Queue()
    frontier.put(initial_state)
    seen = set()

    nodes_expanded, max_nodes_stored, max_search_depth = 0, 1, 0

    while not frontier.empty():
        current_state = frontier.get()
        seen.add(current_state.current_position)
        
        if current_state.current_position == goal_position:
            running_time = time.time() - start_time
            max_ram_usage = (resource.getrusage(resource.RUSAGE_SELF).ru_maxrss - start_ram) / (2**10)
            result_arena = final_arena(current_state.arena, find_path(current_state))
            return result_arena, current_state.cost, nodes_expanded, max_nodes_stored, max_search_depth, running_time, max_ram_usage

        nodes_expanded += 1
       
        for child in current_state.expand():
            if child not in frontier.queue and child.current_position not in seen:
                frontier.put(child)
                max_search_depth = max(max_search_depth, child.cost)
        
        max_nodes_stored = max(max_nodes_stored, frontier.qsize() + len(seen))

    return [], -1, -1, -1, -1, -1, -1
    # =================================#
    # *#*#*# Your code ends here #*#*#*#
    # =================================#


"""
This function runs Depth First Search on the input arena (which is a list of str)
Returns a ([], int) tuple where the [] represents the solved arena as a list of str and the int represents the cost of the solution
"""


def dfs(arena):
    # =================================================#
    # *#*#*# TODO: Write your DFS algorithm here #*#*#*#
    # =================================================#
    start_time = time.time()
    start_ram = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss

    initial_state = MazeState(arena)
    goal_position = initial_state.goal

    frontier = []
    frontier.append(initial_state)
    seen = set()

    nodes_expanded, max_nodes_stored, max_search_depth = 0, 1, 0

    while frontier:
        current_state = frontier.pop()
        seen.add(current_state.current_position)
        
        if current_state.current_position == goal_position:
            running_time = time.time() - start_time
            max_ram_usage = (resource.getrusage(resource.RUSAGE_SELF).ru_maxrss - start_ram) / (2**10)
            result_arena = final_arena(current_state.arena, find_path(current_state))
            return result_arena, current_state.cost, nodes_expanded, max_nodes_stored, max_search_depth, running_time, max_ram_usage

        nodes_expanded += 1
       
        for child in reversed(current_state.expand()):
            if child not in frontier and child.current_position not in seen:
                frontier.append(child)
                max_search_depth = max(max_search_depth, child.cost)
        
        max_nodes_stored = max(max_nodes_stored, len(frontier) + len(seen))

    return [], -1, -1, -1, -1, -1, -1
    # =================================#
    # *#*#*# Your code ends here #*#*#*#
    # =================================#


"""
This function runs A* Search on the input arena (which is a list of str)
Returns a ([], int) tuple where the [] represents the solved arena as a list of str and the int represents the cost of the solution
"""


def astar(arena):
    # ================================================#
    # *#*#*# TODO: Write your A* algorithm here #*#*#*#
    # ================================================#
    start_time = time.time()
    start_ram = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss

    initial_state = MazeState(arena)
    goal_position = initial_state.goal

    frontier = queue.PriorityQueue()
    frontier.put(initial_state)
    seen = set()

    nodes_expanded, max_nodes_stored, max_search_depth = 0, 1, 0

    while not frontier.empty():
        current_state = frontier.get()
        seen.add(current_state.current_position)
        
        if current_state.current_position == goal_position:
            running_time = time.time() - start_time
            max_ram_usage = (resource.getrusage(resource.RUSAGE_SELF).ru_maxrss - start_ram) / (2**10)
            result_arena = final_arena(current_state.arena, find_path(current_state))
            return result_arena, current_state.cost, nodes_expanded, max_nodes_stored, max_search_depth, running_time, max_ram_usage

        nodes_expanded += 1
       
        for child in current_state.expand():
            if child not in frontier.queue and child.current_position not in seen:
                frontier.put(child)
                max_search_depth = max(max_search_depth, child.cost)
            
        max_nodes_stored = max(max_nodes_stored, frontier.qsize() + len(seen))

    return [], -1, -1, -1, -1, -1, -1
    # =================================#
    # *#*#*# Your code ends here #*#*#*#
    # =================================#


"""
This function runs Iterative Deepening A* Search on the input arena (which is a list of str)
Returns a ([], int) tuple where the [] represents the solved arena as a list of str and the int represents the cost of the solution
"""


def ida(arena):
    # =================================================#
    # *#*#*# TODO: Write your IDA algorithm here #*#*#*#
    # =================================================#
    
    def dls(state, max_cost):
        nonlocal nodes_expanded, max_nodes_stored, max_search_depth 
        frontier = []
        frontier.append(state)

        min_cost = float("inf")
        while frontier:
            current_state = frontier.pop()
            
            if current_state.current_position == state.goal:
                result_arena = final_arena(current_state.arena, find_path(current_state))
                return -1, result_arena, current_state.cost, nodes_expanded, max_nodes_stored, max_search_depth

            nodes_expanded += 1
        
            for child in reversed(current_state.expand()):
                child_cost = total_cost(child)
                if child_cost > max_cost:
                    min_cost = min(min_cost, child_cost)
                    continue
                    
                if child not in frontier:
                    frontier.append(child)
                    max_search_depth = max(max_search_depth, child_cost)
            
            max_nodes_stored = max(max_nodes_stored, len(frontier))
        
        return min_cost, [], -1, -1, -1, -1

    nodes_expanded, max_nodes_stored, max_search_depth = 0, 1, 0
    start_time = time.time()
    start_ram = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss

    initial_state = MazeState(arena)
    max_cost = total_cost(initial_state)

    while True:
        result = dls(initial_state, max_cost)

        if result[0] == -1: 
            running_time = time.time() - start_time
            max_ram_usage = (resource.getrusage(resource.RUSAGE_SELF).ru_maxrss - start_ram) / (2**10)
            _, result_arena, cost, nodes_expanded, max_nodes_stored, max_search_depth = result
            return result_arena, cost, nodes_expanded, max_nodes_stored, max_search_depth, running_time, max_ram_usage

        max_cost = result[0] 
    # =================================#
    # *#*#*# Your code ends here #*#*#*#
    # =================================#


if __name__ == "__main__":
    if results.bfs:
        print("\nBFS algorithm called")
        (
            bfs_arena,
            bfs_cost,
            bfs_nodes_expanded,
            bfs_max_nodes_stored,
            bfs_max_search_depth,
            bfs_time,
            bfs_ram,
        ) = bfs(arena)
        print("\n".join(bfs_arena))
        print("BFS:")
        print("Cost: " + str(bfs_cost))
        print("Nodes Expanded: " + str(bfs_nodes_expanded))
        print("Max Nodes Stored: " + str(bfs_max_nodes_stored))
        print("Max Search Depth: " + str(bfs_max_search_depth))
        print("Time: " + str(bfs_time) + "s")
        print("RAM Usage: " + str(bfs_ram) + "kB\n")

    if results.dfs:
        print("\nDFS algorithm called")
        (
            dfs_arena,
            dfs_cost,
            dfs_nodes_expanded,
            dfs_max_nodes_stored,
            dfs_max_search_depth,
            dfs_time,
            dfs_ram,
        ) = dfs(arena)
        print("\n".join(dfs_arena))
        print("DFS:")
        print("Cost: " + str(dfs_cost))
        print("Nodes Expanded: " + str(dfs_nodes_expanded))
        print("Max Nodes Stored: " + str(dfs_max_nodes_stored))
        print("Max Search Depth: " + str(dfs_max_search_depth))
        print("Time: " + str(dfs_time) + "s")
        print("RAM Usage: " + str(dfs_ram) + "kB\n")

    if results.astar:
        print("\nA* algorithm called")
        (
            astar_arena,
            astar_cost,
            astar_nodes_expanded,
            astar_max_nodes_stored,
            astar_max_search_depth,
            astar_time,
            astar_ram,
        ) = astar(arena)
        print("\n".join(astar_arena))
        print("A*:")
        print("Cost: " + str(astar_cost))
        print("Nodes Expanded: " + str(astar_nodes_expanded))
        print("Max Nodes Stored: " + str(astar_max_nodes_stored))
        print("Max Search Depth: " + str(astar_max_search_depth))
        print("Time: " + str(astar_time) + "s")
        print("RAM Usage: " + str(astar_ram) + "kB\n")

    if results.ida:
        print("\nIterative Deepening A* algorithm called")
        (
            ida_arena,
            ida_cost,
            ida_nodes_expanded,
            ida_max_nodes_stored,
            ida_max_search_depth,
            ida_time,
            ida_ram,
        ) = ida(arena)
        print("\n".join(ida_arena))
        print("Iterative Deepening A*:")
        print("Cost: " + str(ida_cost))
        print("Nodes Expanded: " + str(ida_nodes_expanded))
        print("Max Nodes Stored: " + str(ida_max_nodes_stored))
        print("Max Search Depth: " + str(ida_max_search_depth))
        print("Time: " + str(ida_time) + "s")
        print("RAM Usage: " + str(ida_ram) + "kB\n")
